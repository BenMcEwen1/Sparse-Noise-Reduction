import scipy.io.wavfile as wave
import numpy as np
import pywt
from scipy.signal import chirp
from scipy.stats import entropy, kstest, uniform
import matplotlib.pyplot as plt
import time
from math import ceil, floor
from matplotlib.patches import Polygon

def decomposeFull(signal, wavelet='dmey', levels=5, plot=False):
    
    # Return leaf coeffs of full tree
    coeffs = [signal]

    for i in range(levels):
        temp = []
        for coeff in coeffs:
            (A,D) = pywt.dwt(coeff, wavelet)
            temp.append(A) 
            temp.append(D) 
        
        coeffs = temp

    if plot:
        fig, ax = plt.subplots(len(coeffs))
        for i, coeff in enumerate(coeffs):
            ax[i].plot(coeff)
        plt.show()

    return coeffs

def reconstructFull(coeffs, wavelet='dmey', plot=False):
    # Reconstruct full wavelet tree
    upper = []
    levels = int(np.log2(len(coeffs)))

    for l in range(levels):
        for i in range(1, len(coeffs), 2):
            U = pywt.idwt(coeffs[i-1], coeffs[i], wavelet)
            upper.append(U)
        coeffs = upper
        upper = []

    if plot:
        fig, ax = plt.subplots(len(coeffs))
        for i, coeff in enumerate(coeffs):
            ax[i].plot(coeff)
        plt.show()

    return coeffs[0]

def thresholdFull(signal, wavelet='dmey', levels=5):

    coeffs = decomposeFull(signal, wavelet=wavelet, levels=levels, plot=False)

    print(f"Number of leaves: {len(coeffs)}, Coeffs per leaf: {len(coeffs[0])}")

    edge = 0

    boxWidth = int((len(coeffs[0])-edge*2)/10)
    boxWidth = int(sampleRate*len(coeffs[0])/len(signal))
    boxHeight = int(len(coeffs)/60)
    numboxesV = floor(len(coeffs)/boxHeight)
    numboxesH = floor((len(coeffs[0])-edge*2)/boxWidth)
    print(f'{numboxesH} boxes {boxWidth} wide, {numboxesV} boxes {boxHeight} tall')
    
    coeffs = np.array(coeffs)

    boxvals = np.empty((numboxesV, numboxesH, boxHeight, boxWidth))
    boxes = np.empty((numboxesV, numboxesH, 4))
    print(np.shape(boxvals))

    for i in range(numboxesV):
        for j in range(numboxesH):
            boxvals[i,j] = np.array(coeffs[boxHeight*i:boxHeight*(i+1),boxWidth*j:boxWidth*(j+1)])
            boxes[i,j] = np.array([boxHeight*i,boxHeight*(i+1),boxWidth*j,boxWidth*(j+1)])

    maxRowEs = []
    minRowStds = []
    maxColEs = []
    minColStds = []
    # maxRowStds = []

    for j in range(len(boxvals[0])):
        maxe = 0
        minstd = 999999
        for i in range(len(boxvals)):
            if entropy(abs(boxvals[i,j].flatten()))>maxe:
                maxe = entropy(abs(boxvals[i,j].flatten()))
                minstd = np.std(boxvals[i,j].flatten())
        maxColEs.append(maxe)
        minColStds.append(minstd)
    
    rowVariance = []
    for i in range(len(boxvals)):
        maxe = 0
        minstd = 999999
        stdDevs = []
        for j in range(len(boxvals[0])):

            stdDevs.append(np.std(boxvals[i,j].flatten()))

            if entropy(abs(boxvals[i,j].flatten()))>maxe:
                minstd = np.std(boxvals[i,j].flatten())
                maxe = entropy(abs(boxvals[i,j].flatten()))
        maxRowEs.append(maxe)
        minRowStds.append(minstd)
        
        rowVariance.append(np.std(stdDevs))
    
    # boxStdevs = np.empty([len(boxes),len(boxes[0])])
    # boxEs = boxStdevs
    # for i in range(len(boxStdevs)):
    #     for j in range(len(boxStdevs[0])):
    #         boxStdevs[i,j] = np.std(boxvals[i,j].flatten())
    #         boxEs[i,j] = entropy(abs(boxvals[i,j].flatten()))

    for ii, boxrows in enumerate(boxes):
        
        relVariance = (rowVariance[ii]-min(rowVariance))/(max(rowVariance)-min(rowVariance))
        thres = minRowStds[ii]*4.5 #threshold is 4.5 * the standard deviation of the lowest entropy box in the row
        softness = 0.3
        print(f'row {ii}, relative variance {relVariance}')
        
        for jj, box in enumerate(boxes[ii]):

            thres = max(minRowStds[ii]*4.5, minColStds[jj]*4.5) #threshold is 4.5 * the standard deviation of the lowest entropy box in the row or column

            if entropy(abs(coeffs[int(box[0]):int(box[1]),int(box[2]):int(box[3])].flatten())) > maxRowEs[ii]*0.5:
                for i in range(int(box[0]),int(box[1])):
                    for j in range(int(box[2]),int(box[3])):
                        if coeffs[i,j] < thres:
                            coeffs[i,j] *= softness

    # Reconstruct each level
    signal = reconstructFull(coeffs, wavelet=wavelet, plot=False) # Full tree reconstruction

    return signal

def thresholdPartial(signal, wavelet='dmey', levels=5):

    coeffs = pywt.wavedec(signal, wavelet='dmey',mode='symmetric', level=levels)

    specGraphBoxes = [[],[]]
    boxes = []
    boxEs = []
    boxStds = []
    rowVariance = []
    rowminStd = []

    for i,coeff in enumerate(coeffs):
        print(f'layer {i}, time coeffs: {len(coeff)}')
        specGraphBoxes.append([])

        boxwidth = int(len(coeff)/80)
        numboxes = floor(len(coeff)/boxwidth)

        if ((sampleRate/2) * 1/(2**(levels-i+1))) < 600: #threshold low freqencies
            coeff *= 0.2

        rowBegin = len(boxEs)

        for j in range(0,len(coeff)-boxwidth,boxwidth):
            boxvals = coeff[j:j+boxwidth]
            boxes.append([i,j,j+boxwidth])
            boxEs.append(entropy(abs(boxvals)))
            boxStds.append(np.std(boxvals))

        rowVariance.append(max(boxStds[rowBegin:])-min(boxStds[rowBegin:]))
        rowminStd.append(min(boxStds[rowBegin:]))

    maxE = max(np.array(boxEs))
    minE = min(np.array(boxEs))
    maxStd = max(np.array(boxStds))
    minStd = min(np.array(boxStds))

    count = 0
    for k,box in enumerate(boxes):
        thres = rowminStd[box[0]]*4.5
        softness = (rowVariance[box[0]]-min(rowVariance))/(max(rowVariance)-min(rowVariance))

        for j in range(box[1],box[2]):
            if coeffs[box[0]][j] < thres:
                coeffs[box[0]][j] *= softness


    #frequency bands
    freqs = np.zeros(levels+2)
    for i in range(levels+1):
        freqs[i] = (sampleRate/2) * 1/(2**(levels-i+1))
    freqs[0] = 0
    freqs[levels+1] = sampleRate/2

    #make coordinates for boxes on spectogram
    for i,box in enumerate(boxes):
        relativeStd = (boxStds[i]-minStd)/(maxStd-minStd)
        relativeE = (boxEs[i]-minE)/(maxE-minE)

        cos = np.zeros(4)
        cos[0] = freqs[box[0]]
        cos[1] = freqs[box[0]+1]

        cos[2] = ((box[1])/(len(coeffs[box[0]])))*(len(signal)/sampleRate)
        cos[3] = ((box[2])/(len(coeffs[box[0]])))*(len(signal)/sampleRate)

        rect = [[cos[2],cos[0]],[cos[3],cos[0]],[cos[3],cos[1]],[cos[2],cos[1]]]
        rect0 = Polygon(rect, fill=True, color=[relativeE,relativeE,relativeE])
        specGraphBoxes[0].append(rect0)
        rect1 = Polygon(rect, fill=True, color=[relativeStd,relativeStd,relativeStd])
        specGraphBoxes[1].append(rect1)

    signal = pywt.waverec(coeffs, wavelet='dmey')

    return signal, specGraphBoxes

sampleRate, signal = wave.read('recordings/cat.wav') # possum.wav works well Haar or dmey, 5, partial, thres=96*4.5
form = signal.dtype
wavelet = 'dmey'
print(sampleRate)

level = pywt.dwt_max_level(len(signal), wavelet)

print(f"Max level: {level}")

start = time.time()
denoised = thresholdFull(signal, wavelet=wavelet, levels=level)
# denoised, specGraphBoxes = thresholdPartial(signal, wavelet=wavelet, levels=level)


print(f'Time taken: {time.time()-start} seconds')

plt.figure()
plt.title('Original/Denoised signal')
plt.plot(signal,color='black')
plt.plot(denoised)

fig, ([ax1, ax2]) = plt.subplots(2)
fig.suptitle('Original/Denoised Spectrogram')
ax1.specgram(signal, Fs=sampleRate)
denoised = np.asarray(denoised, dtype=form) # Downsample
ax2.specgram(denoised, Fs=sampleRate)
# ax3.specgram(signal, Fs=sampleRate)
# ax4.specgram(signal, Fs=sampleRate)
# ax4.set_title('standard deviations')
# ax3.set_title('entropy')
ax2.set_title('denoised')

# for box in specGraphBoxes[0]:#horizontal boxes
#     ax3.add_patch(box)
# for box in specGraphBoxes[1]:#horizontal boxes
#     ax4.add_patch(box)

plt.show()

# Save denoised signal
wave.write('denoised/denoised.wav', sampleRate*int(len(denoised)/len(signal)), denoised)
